from datetime import datetime
from multiprocessing import Array, Lock, Process, Semaphore, Value
import os
import random
import time
from typing import Any, Dict, List
from configs import *
from jackpot import Jackpot
from key import Key, get_numbers_from_key, get_stars_from_key
from logger import Logger


# time_now_str represents the current datetime when the main process started to run
time_now_str = datetime.now().strftime("%Y-%m-%d_%H:%M:%S")


# concurrent_bets represents the semaphore that controls the concurrent number of bets
concurrent_bets = Semaphore(MAX_CONCURRENT_BETS)

# evaluate_bets represents the semaphore that controls when the clients are able to evaluate their bets
evaluate_bets = Semaphore(0)


# bets_closed defines whether the server is closed or open to new bets
bets_closed: Any = Value("i", 0)
mutex_beats_closed = Lock()


# are_bets_closed returns true if the server already closed the betting stage, or false otherwise
def are_bets_closed() -> bool:
    mutex_beats_closed.acquire()
    ok = bool(bets_closed.value)
    mutex_beats_closed.release()
    return ok


# close_bets closes the betting stage
def close_bets() -> None:
    mutex_beats_closed.acquire()
    bets_closed.value = 1
    mutex_beats_closed.release()


# bets represents the current bets
bets: List[Any] = [None] * NUM_PLAYERS
for i in range(NUM_PLAYERS):
    bet = Array("i", AMOUNT_GENERATED_TOTAL)
    bets[i] = bet
mutex_bets = Lock()


# get_bets returns all the current bets
def get_bets() -> List[Any]:
    mutex_bets.acquire()
    bets_copy: List[List[int]] = []
    for i in range(len(bets)):
        bets_copy.append(bets[i][:])
    mutex_bets.release()
    return bets_copy


# set_bet sets the given bet for the given client index
def set_bet(index: int, bet: List[int]) -> None:
    if index < 0 or index >= NUM_PLAYERS:
        raise IndexError("bet index out of range")

    mutex_bets.acquire()
    for i in range(AMOUNT_GENERATED_TOTAL):
        bets[index][i] = bet[i]
    mutex_bets.release()


# server_key represents the key generated by the server
server_key = Array("i", AMOUNT_GENERATED_TOTAL)
mutex_server_key = Lock()


# get_server_key returns the key generated by the server
def get_server_key() -> List[int]:
    mutex_server_key.acquire()
    key_copy: List[int] = []
    for i in range(AMOUNT_GENERATED_TOTAL):
        key_copy.append(server_key[i])
    mutex_server_key.release()
    return key_copy


# set_server_key sets the server key
def set_server_key(key: List[int]) -> None:
    mutex_server_key.acquire()
    for i in range(AMOUNT_GENERATED_TOTAL):
        server_key[i] = key[i]
    mutex_server_key.release()


# check_prizes checks and logs the prizes that have been won.
# It also returns the number of the prize won [1; 13] or 0 if none
def check_prizes(
    log: Logger,
    client_index: int,
    key: Key,
    otherKey: List[int],
) -> int:
    jackpot = Jackpot(JACKPOT_AMOUNT_FILE, PRIZE1_AMOUNT)
    jackpot_amount = jackpot.get_current_jackpot()

    jackpot_message = "client-{} got the jackpot: {} €"
    prize_message = "client-{} got the {} prize: {} €"

    if key.check_prize(otherKey, PRIZE1_NUMBERS, PRIZE1_STARS):
        log.log_info(jackpot_message.format(client_index, jackpot_amount))
        return 1

    if key.check_prize(otherKey, PRIZE2_NUMBERS, PRIZE2_STARS):
        log.log_info(prize_message.format(client_index, "2nd", PRIZE2_AMOUNT))
        return 2

    if key.check_prize(otherKey, PRIZE3_NUMBERS, PRIZE3_STARS):
        log.log_info(prize_message.format(client_index, "3rd", PRIZE3_AMOUNT))
        return 3

    if key.check_prize(otherKey, PRIZE4_NUMBERS, PRIZE4_STARS):
        log.log_info(prize_message.format(client_index, "4th", PRIZE4_AMOUNT))
        return 4

    if key.check_prize(otherKey, PRIZE5_NUMBERS, PRIZE5_STARS):
        log.log_info(prize_message.format(client_index, "5th", PRIZE5_AMOUNT))
        return 5

    if key.check_prize(otherKey, PRIZE6_NUMBERS, PRIZE6_STARS):
        log.log_info(prize_message.format(client_index, "6th", PRIZE6_AMOUNT))
        return 6

    if key.check_prize(otherKey, PRIZE7_NUMBERS, PRIZE7_STARS):
        log.log_info(prize_message.format(client_index, "7th", PRIZE7_AMOUNT))
        return 7

    if key.check_prize(otherKey, PRIZE8_NUMBERS, PRIZE8_STARS):
        log.log_info(prize_message.format(client_index, "8th", PRIZE8_AMOUNT))
        return 8

    if key.check_prize(otherKey, PRIZE9_NUMBERS, PRIZE9_STARS):
        log.log_info(prize_message.format(client_index, "9th", PRIZE9_AMOUNT))
        return 9

    if key.check_prize(otherKey, PRIZE10_NUMBERS, PRIZE10_STARS):
        log.log_info(prize_message.format(client_index, "10th", PRIZE10_AMOUNT))
        return 10

    if key.check_prize(otherKey, PRIZE11_NUMBERS, PRIZE11_STARS):
        log.log_info(prize_message.format(client_index, "11th", PRIZE11_AMOUNT))
        return 11

    if key.check_prize(otherKey, PRIZE12_NUMBERS, PRIZE12_STARS):
        log.log_info(prize_message.format(client_index, "12th", PRIZE12_AMOUNT))
        return 12

    if key.check_prize(otherKey, PRIZE13_NUMBERS, PRIZE13_STARS):
        log.log_info(prize_message.format(client_index, "13th", PRIZE13_AMOUNT))
        return 13

    return 0


# server executes the server process
def server() -> None:
    logs_path = os.path.join(LOGS_FOLDER, time_now_str)
    log = Logger(logs_path, "server")

    log.log_info("process initialized")
    log.log_info("starting the betting stage")

    registered_bets: Dict[int, List[int]] = {}
    start_time = datetime.now()

    # wait for new bets
    while True:
        current_bets = get_bets()
        for i in range(len(current_bets)):
            # ignore already registered bets
            if i in registered_bets:
                continue

            # ignore empty bets
            bet = current_bets[i][:]
            if bet[0] == 0:
                continue

            # register bet
            registered_bets[i] = bet
            concurrent_bets.release()

            log.log_info(
                "bet from client-{} registered for numbers: {}; and stars: {}".format(
                    i,
                    get_numbers_from_key(
                        bet, AMOUNT_GENERATED_NUMBERS, AMOUNT_GENERATED_STARS
                    ),
                    get_stars_from_key(
                        bet, AMOUNT_GENERATED_NUMBERS, AMOUNT_GENERATED_STARS
                    ),
                )
            )

        # check if the cycle should be interrupted
        if are_bets_closed():
            log.log_info("closing the betting stage")
            break

        # check if the maximum waiting time has been reached
        time_since_start = datetime.now() - start_time
        time_since_start = time_since_start.total_seconds()
        if time_since_start >= MAX_WAIT_TIME:
            log.log_info("the maximum waiting time has been reached")
            close_bets()

        # check if all bets have been registered
        if len(registered_bets) == NUM_PLAYERS:
            log.log_info("all players have already placed their bets")
            close_bets()

    # generate key
    key = Key(
        NUMBER_MIN,
        NUMBER_MAX,
        STAR_MIN,
        STAR_MAX,
        AMOUNT_GENERATED_NUMBERS,
        AMOUNT_GENERATED_STARS,
    )
    key.generate()

    log.log_info(
        "key generated with numbers: {}; and stars: {}".format(
            key.get_numbers(),
            key.get_stars(),
        )
    )

    # check prizes
    jackpot = Jackpot(JACKPOT_AMOUNT_FILE, PRIZE1_AMOUNT)
    jackpot.remove_old_jackpot()
    jackpot_amount = jackpot.get_current_jackpot()

    log.log_info("current jackpot is {} €".format(jackpot_amount))

    count_loss = 0
    jackpot_hit = False

    for i, bet in registered_bets.items():
        prize_won = check_prizes(log, i, key, bet)
        if prize_won == 0:
            count_loss += 1
        elif prize_won == 1:
            jackpot_hit = True

    # no prizes were awarded
    if count_loss == len(registered_bets):
        log.log_info("no one has won any prizes")

    if jackpot_hit:
        log.log_info(
            "resetting the jackpot to {} € since someone has won it".format(
                PRIZE1_AMOUNT
            )
        )

        # reset jackpot
        jackpot.set_new_jackpot(PRIZE1_AMOUNT)
    else:
        log.log_info(
            "adding {} € to the jackpot, since no one has won it".format(
                PRIZE1_AMOUNT_INCREMENT
            )
        )

        # accumulate jackpot
        jackpot_amount += PRIZE1_AMOUNT_INCREMENT
        jackpot.set_new_jackpot(jackpot_amount)

    # allow the clients to evaluate their bets
    set_server_key(key.get_key())
    for _ in range(len(registered_bets)):
        evaluate_bets.release()


# client executes the player process
def client(index: int) -> None:
    logs_path = os.path.join(LOGS_FOLDER, time_now_str)
    log = Logger(logs_path, "client-" + str(index))

    log.log_info("process initialized")

    # use the first three players to simulate possible late bets
    if index < 3 and random.uniform(0, 1) <= 0.3:
        sleep_time = MAX_WAIT_TIME + 1
        log.log_info("going to be late for {} s".format(sleep_time))
        time.sleep(sleep_time)

    # check if the server is open
    if are_bets_closed():
        log.log_error("tried to bet, but the server was already closed")
        return

    # start the betting process
    log.log_info("waiting to bet")
    concurrent_bets.acquire()

    # generate bet
    log.log_info("generating bet")
    key = Key(
        NUMBER_MIN,
        NUMBER_MAX,
        STAR_MIN,
        STAR_MAX,
        AMOUNT_GENERATED_NUMBERS,
        AMOUNT_GENERATED_STARS,
    )
    key.generate()

    try:
        set_bet(index, key.get_key())
    except IndexError as e:
        log.log_error("failed to register bet: {}".format(e.__str__()))
        concurrent_bets.release()
        return

    log.log_info(
        "bet made for numbers: {}; and stars: {}".format(
            key.get_numbers(),
            key.get_stars(),
        )
    )

    # evaluate bet result when available
    evaluate_bets.acquire()

    evaluate_key = get_server_key()
    log.log_info(
        "got the server key with numbers: {}; and stars: {}".format(
            get_numbers_from_key(
                evaluate_key, AMOUNT_GENERATED_NUMBERS, AMOUNT_GENERATED_STARS
            ),
            get_stars_from_key(
                evaluate_key, AMOUNT_GENERATED_NUMBERS, AMOUNT_GENERATED_STARS
            ),
        )
    )

    prize_won = check_prizes(log, index, key, evaluate_key)
    if prize_won == 0:
        log.log_info("client-{} did not get any prizes".format(index))


if __name__ == "__main__":
    # start the server process
    server_process = Process(target=server)
    server_process.start()

    # start the client processes
    client_processes: List[Process] = []

    for i in range(NUM_PLAYERS):
        process = Process(target=client, args=[i])
        process.start()

        client_processes.append(process)

    # join processes
    server_process.join()

    for i in range(NUM_PLAYERS):
        client_processes[i].join()
